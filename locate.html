<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bud Finder</title>

  <!--
    OPTIONAL:
    - Update these paths to match your project structure.
    - Favicon path must exist, or remove this line.
  -->
  <link rel="icon" type="image/x-icon" href="images/IMG_5124.ico" />

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />

  <!-- PapaParse for CSV parsing -->
  <script src="https://unpkg.com/papaparse@5.3.2/papaparse.min.js"></script>

  <style>
    /* =========================================================
       Layout
       ========================================================= */

    /* Desktop: map 75% left, directions 25% right */
    @media (min-width: 768px) {
      #map {
        display: none;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 25%;
      }
      #instructions {
        display: none;
        position: absolute;
        top: 0;
        bottom: 0;
        right: 0;
        width: 25%;
      }
    }

    /* Mobile: map top 2/3, directions bottom 1/3 */
    @media (max-width: 767px) {
      #map {
        display: none;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 33%;
      }
      #instructions {
        display: none;
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 33%;
        width: 100%;
      }
    }

    /* Common styles */
    #map,
    #instructions {
      background: #fafafa;
      overflow: auto;
      padding: 8px;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
    }

    .controls {
      position: absolute;
      display: none;           /* hidden until CSV is loaded */
      top: 10px;
      left: 10px;
      background: white;
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
      font-family: sans-serif;
      z-index: 1002;
    }

    #upload-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      width: min(92vw, 420px);
      padding: 18px;
      border-radius: 10px;
      border: 1px solid #e5e5e5;
      box-shadow: 0 8px 22px rgba(0,0,0,0.14);
      text-align: left;
      font-family: sans-serif;
      z-index: 1003;
    }

    #upload-panel h3 {
      margin: 0 0 8px;
      font-size: 20px;
    }

    #upload-panel .upload-hint {
      margin: 0 0 12px;
      font-size: 13px;
      line-height: 1.4;
      color: #444;
    }

    #upload-panel button {
      display: none;
      margin-top: 10px;
      padding: 6px 10px;
    }

    #ui-toggles {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1004;
      display: none;           /* shown after CSV load */
      font-family: sans-serif;
    }

    #menu-dropdown {
      position: relative;
    }

    #menu-dropdown > summary {
      list-style: none;
      cursor: pointer;
      user-select: none;
      background: white;
      padding: 6px 10px;
      border-radius: 4px;
      border: 1px solid #d6d6d6;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
    }

    #menu-dropdown > summary::-webkit-details-marker {
      display: none;
    }

    #menu-dropdown[open] > summary {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }

    .menu-dropdown-body {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin: 0;
      padding: 8px;
      min-width: 170px;
      background: white;
      border: 1px solid #d6d6d6;
      border-top: none;
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
      box-shadow: 0 1px 5px rgba(0,0,0,0.3);
    }

    .menu-dropdown-body button {
      width: 100%;
      text-align: left;
    }

    #strain-list-panel {
      position: absolute;
      top: 100px;
      right: 10px;
      z-index: 1004;
      display: none;
      width: min(88vw, 280px);
      max-height: 72vh;
      background: white;
      padding: 8px;
      border-radius: 8px;
      box-shadow: 0 1px 7px rgba(0,0,0,0.3);
      font-family: sans-serif;
    }

    .strain-list-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    #strain-list-search {
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 6px;
    }

    #strain-list-status {
      margin-bottom: 6px;
      font-size: 12px;
      color: #444;
    }

    #strain-list {
      max-height: 48vh;
      overflow-y: auto;
      border: 1px solid #ececec;
      border-radius: 6px;
      background: #fafafa;
      padding: 4px;
    }

    .strain-item {
      width: 100%;
      margin: 3px 0;
      text-align: left;
      border: 1px solid #d8d8d8;
      background: white;
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 13px;
      cursor: pointer;
    }

    .strain-item.active {
      background: #e8f2ff;
      border-color: #7aa7e8;
      font-weight: 700;
    }

    .strain-empty {
      padding: 8px;
      font-size: 12px;
      color: #666;
    }

    .popup-strains-box {
      margin: 8px 0;
      border: 1px solid #e4e4e4;
      border-radius: 6px;
      background: #fafafa;
      padding: 6px;
      max-height: 170px;
      overflow-y: auto;
    }

    .popup-strains-count {
      margin: 0 0 4px;
      font-size: 12px;
      font-weight: 700;
      color: #333;
    }

    .popup-strains-list {
      margin: 0;
      padding-left: 18px;
      font-size: 12px;
      line-height: 1.35;
      color: #222;
    }

    .popup-strains-list li {
      margin: 2px 0;
    }

    .popup-strains-status,
    .popup-strains-empty {
      margin: 0;
      font-size: 12px;
      color: #555;
    }

    @media (max-width: 767px) {
      #strain-list-panel {
        top: 52px;
        right: 10px;
        width: calc(100vw - 20px);
        max-height: 52vh;
      }

      #strain-list {
        max-height: 36vh;
      }
    }

    /* =========================================================
       NEW: Logo marker styling (purely visual polish)
       =========================================================
       Leaflet applies the icon image to <img> tags, but we can
       still use a className for easy CSS polishing.
    */
    .shop-logo-icon {
      border-radius: 8px;
      background: white;
      padding: 2px;
      box-sizing: border-box;
      overflow: hidden;
      border: 1px solid #d7d7d7;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shop-logo-icon img {
      max-width: 100% !important;
      max-height: 100% !important;
      width: auto !important;
      height: auto !important;
      object-fit: contain !important;
      object-position: center center !important;
      display: block;
      border-radius: 0;
      background: white;
    }
  </style>
</head>

<body>
  <!-- Initial panel while locating/loading CSV -->
  <div id="upload-panel">
    <h3 id="upload-title">Loading locations CSV</h3>
    <p id="upload-message" class="upload-hint">Looking for the first CSV in locations/...</p>
    <button id="manual-csv-btn" type="button">Choose CSV manually</button>
    <button id="folder-csv-btn" type="button">Choose locations folder</button>
  </div>

  <!-- Map and directions containers -->
  <div id="map"></div>
  <div id="instructions"></div>

  <!-- Compact top-right menu -->
  <div id="ui-toggles">
    <details id="menu-dropdown">
      <summary>Menu</summary>
      <div class="menu-dropdown-body">
        <button id="toggle-controls" type="button">Show controls</button>
        <button id="toggle-directions" type="button">Show directions</button>
        <button id="toggle-strain-list" type="button">Show strains</button>
        <button id="change-csv-btn" type="button">Change CSV</button>
      </div>
    </details>
  </div>
  <input type="file" id="file-input" accept=".csv" style="display:none;" />

  <!-- Main controls panel -->
  <div class="controls">
    <label for="destination-select">Destination:</label>
    <select id="destination-select"></select><br />

    <label for="mode">Mode:</label>
    <select id="mode">
      <option value="walking">Walking</option>
      <option value="driving">Driving</option>
      <option value="cycling">Cycling</option>
    </select><br />

    <div id="csv-switch-wrap" style="display:none; margin-top:8px;">
      <label for="csv-switch-select">Location CSV:</label>
      <select id="csv-switch-select" style="width:100%;"></select>
    </div>

    <div id="time-estimate" style="margin-top:8px;">ETA: --</div>
    <div id="distance-info"></div>
    <br />

    <!-- Category filters as tick boxes -->
    <div id="category-filters">
      <!-- Checkboxes injected here by JS -->
    </div>

    <div style="margin-top:8px;">
      <label for="strain-filter">Strain filter (database)</label>
      <input id="strain-filter" type="text" placeholder="e.g. amnesia haze" style="width:100%;">
      <div style="display:flex; gap:6px; margin-top:6px; flex-wrap:wrap;">
        <button id="apply-strain-btn" type="button">Apply strain filter</button>
        <button id="clear-strain-btn" type="button">Clear strain filter</button>
      </div>
      <div id="strain-status" style="margin-top:6px; font-size:12px; color:#444;">Strain filter: off</div>
    </div>

    <button id="nearest-btn">Nearest</button><br />
    <div id="db-status" style="display:none; margin-top:6px; font-size:12px; color:#444;"></div>
  </div>

  <div id="strain-list-panel">
    <div class="strain-list-head">
      <strong>Active strains</strong>
      <button id="close-strain-list" type="button">Close</button>
    </div>
    <input id="strain-list-search" type="text" placeholder="Filter strains..." />
    <div id="strain-list-status">Load CSV first.</div>
    <div id="strain-list"></div>
  </div>

  <!-- Leaflet + Routing JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>

  <script>
    // =========================================================
    // Global state
    // =========================================================

    let map = null;
    let routingControl = null;
    let lastPosition = null;
    let geolocationWatchId = null;
    let locations = [];            // parsed locations from CSV
    let markers = [];              // Leaflet markers
    let controlsVisible = false;   // controls panel visibility
    let directionsVisible = false; // directions panel visibility
    let strainListVisible = false; // strain list panel visibility

    // Favourite indices stored in localStorage
    let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');

    // Multi-select categories: 'all', 'favourites', and CSV Y/N flags
    let selectedCategories = ['all'];
    let categoryOptions = [];

    // Colour/icon setup for category-based markers (fallback when no logo)
    const _markerColors = ['red','blue','green','orange','yellow','violet','grey','black'];
    const categoryColors = {};
    const categoryIcons = {};
    let defaultIcon;

    // Distance at which we consider "already at this location" (in meters)
    const VISITED_RADIUS_METERS = 5;

    // Where downloaded logos might live (try in order)
    const LOGO_BASE_PATHS = ['logos/', 'images/logos/', '/logos/', '/images/logos/'];
    const FALLBACK_MARKER_ICON_URL =
      'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png';
    const LOGO_MARKER_SIZE = 32;
    const POPUP_LOGO_SIZE = 56;

    // DB integration state
    let dbIntegrationReady = false;
    let dbIntegrationSource = 'none'; // 'flask' | 'json' | 'none'
    let dbRouteLinksEnabled = false;
    let dbByPath = new Map();       // "/cs-shop.html" -> shop_id
    let dbByNameCity = new Map();   // "name|city" -> shop_id
    let dbByUniqueName = new Map(); // "name" -> shop_id when unique

    // Strain filter state (DB-backed)
    let strainFilterText = '';
    let strainAllowedShopIds = null; // Set<number> | null
    let strainAllowedNameCityKeys = null; // Set<string> | null
    let strainIndexRows = null;      // cached JSON strain index
    let activeOfferingsRows = null;  // cached JSON offerings rows
    let activeStrainNames = [];      // clickable strain list for UI panel
    let popupStrainsByShopId = new Map();      // shop_id -> [strain names]
    let popupStrainsByNameCity = new Map();    // "name|city" -> [strain names]
    let popupStrainIndexReady = false;
    let popupStrainIndexPromise = null;
    let discoveredCsvPaths = [];     // discovered CSV paths in the hosted folder
    let currentCsvPath = '';         // current CSV path when loaded from URL

    function setUploadPanelState(titleText, messageText, allowManualCsv) {
      const panel = document.getElementById('upload-panel');
      const title = document.getElementById('upload-title');
      const message = document.getElementById('upload-message');
      const manualBtn = document.getElementById('manual-csv-btn');
      const folderBtn = document.getElementById('folder-csv-btn');
      const isLocalFile = window.location.protocol === 'file:';
      const supportsDirPicker = typeof window.showDirectoryPicker === 'function';
      if (title) title.textContent = titleText || '';
      if (message) message.textContent = messageText || '';
      if (manualBtn) manualBtn.style.display = allowManualCsv ? 'inline-block' : 'none';
      if (folderBtn) folderBtn.style.display =
        (allowManualCsv && isLocalFile && supportsDirPicker) ? 'inline-block' : 'none';
      if (panel) panel.style.display = titleText || messageText || allowManualCsv ? 'block' : 'none';
    }

    function resetMapState() {
      if (geolocationWatchId !== null && navigator.geolocation) {
        try {
          navigator.geolocation.clearWatch(geolocationWatchId);
        } catch (_err) {
          // Ignore if watch id is stale.
        }
        geolocationWatchId = null;
      }

      if (map) {
        try {
          if (routingControl) {
            map.removeControl(routingControl);
          }
        } catch (_err) {
          // Ignore if routing control was already removed.
        }
        map.remove();
        map = null;
      }
      routingControl = null;
      markers = [];
      lastPosition = null;

      const mapDiv = document.getElementById('map');
      const instructionsDiv = document.getElementById('instructions');
      if (mapDiv) mapDiv.innerHTML = '';
      if (instructionsDiv) instructionsDiv.innerHTML = '';
    }

    function setControlsVisible(show) {
      controlsVisible = !!show;
      const controlsDiv = document.querySelector('.controls');
      const btn = document.getElementById('toggle-controls');
      if (controlsDiv) controlsDiv.style.display = controlsVisible ? 'block' : 'none';
      if (btn) btn.textContent = controlsVisible ? 'Hide controls' : 'Show controls';
      if (map) {
        setTimeout(() => map.invalidateSize(), 200);
      }
    }

    function setDirectionsVisible(show) {
      directionsVisible = !!show;
      const directionsDiv = document.getElementById('instructions');
      const mapDiv = document.getElementById('map');
      const btn = document.getElementById('toggle-directions');

      if (directionsDiv) directionsDiv.style.display = directionsVisible ? 'block' : 'none';
      if (btn) btn.textContent = directionsVisible ? 'Hide directions' : 'Show directions';

      if (mapDiv) {
        if (directionsVisible) {
          if (window.innerWidth >= 768) {
            mapDiv.style.right = '25%';
            mapDiv.style.bottom = '0';
          } else {
            mapDiv.style.bottom = '33%';
            mapDiv.style.right = '0';
          }
        } else {
          mapDiv.style.right = '0';
          mapDiv.style.bottom = '0';
        }
      }

      if (map) {
        setTimeout(() => map.invalidateSize(), 200);
      }
    }

    function normaliseText(s) {
      return (s || '').toString().toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
    }

    function normaliseNameCityKey(name, city) {
      return `${normaliseText(name)}|${normaliseText(city)}`;
    }

    function normaliseUrlPath(url) {
      const raw = (url || '').toString().trim();
      if (!raw) return '';
      try {
        const u = new URL(raw, window.location.href);
        return (u.pathname || '').toLowerCase().replace(/\/+$/, '');
      } catch {
        return '';
      }
    }

    function extractShopIdFromHref(href) {
      const m = (href || '').match(/\/shop\/(\d+)/);
      if (!m) return null;
      const id = parseInt(m[1], 10);
      return Number.isFinite(id) ? id : null;
    }

    function logoCandidates(logoFilename) {
      const raw = (logoFilename || '').toString().trim();
      if (!raw) return [];
      const encoded = encodeURIComponent(raw);
      const out = [];
      LOGO_BASE_PATHS.forEach(base => {
        out.push(`${base}${encoded}`);
        out.push(`${base}${raw}`);
      });
      return Array.from(new Set(out));
    }

    function escapeHtmlAttr(s) {
      return (s || '').toString()
        .replace(/&/g, '&amp;')
        .replace(/"/g, '&quot;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function escapeHtml(s) {
      return (s || '').toString()
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
    }

    function tryNextImageCandidate(imgEl) {
      const all = (imgEl.dataset.candidates || '').split('|').filter(Boolean);
      const i = parseInt(imgEl.dataset.idx || '0', 10) + 1;
      if (i < all.length) {
        imgEl.dataset.idx = String(i);
        imgEl.src = all[i];
        return true;
      }
      return false;
    }

    // Used by popup <img onerror> to try fallback logo paths.
    function popupLogoFallback(imgEl) {
      const advanced = tryNextImageCandidate(imgEl);
      if (!advanced) {
        imgEl.style.display = 'none';
      }
    }

    // Same fallback logic for marker logo images.
    // If no logo path works, use a plain marker pin image.
    function markerLogoFallback(imgEl) {
      const advanced = tryNextImageCandidate(imgEl);
      if (!advanced) {
        imgEl.onerror = null;
        imgEl.src = FALLBACK_MARKER_ICON_URL;
        imgEl.style.maxWidth = '100%';
        imgEl.style.maxHeight = '100%';
        imgEl.style.width = 'auto';
        imgEl.style.height = 'auto';
        imgEl.style.objectFit = 'contain';
        imgEl.style.objectPosition = 'center center';
        imgEl.style.padding = '0';
        imgEl.style.background = 'transparent';
        imgEl.style.margin = '0 auto';
      }
    }
    window.popupLogoFallback = popupLogoFallback;
    window.markerLogoFallback = markerLogoFallback;

    // =========================================================
    // Icons
    // =========================================================

    /**
     * Initialise marker icons for each category, with different colours.
     * These are used when a location doesn't have a logo.
     */
    function initCategoryIcons() {
      // Assign each category (except 'all' and 'favourites') a colour
      categoryOptions
        .filter(c => c !== 'all' && c !== 'favourites')
        .forEach((cat, idx) => {
          categoryColors[cat] = _markerColors[idx % _markerColors.length];
        });

      // Create actual Leaflet icons for category pins
      Object.entries(categoryColors).forEach(([cat, color]) => {
        categoryIcons[cat] = new L.Icon({
          iconUrl: `https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-${color}.png`,
          shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });
      });

      // Default grey icon if no category match
      defaultIcon = new L.Icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-grey.png',
        shadowUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });
    }

    /**
     * NEW:
     * Create a Leaflet icon using a coffee shop logo filename from the CSV.
     * If logo is missing/blank, return null so we can fall back to pin icons.
     *
     * CSV column: logo
     * Example value: boerejongens.png
     */
    function createLogoIcon(logoFilename) {
      const candidates = logoCandidates(logoFilename);
      if (!candidates.length) return null;
      const joined = candidates.map(escapeHtmlAttr).join('|');
      const first = escapeHtmlAttr(candidates[0]);

      return L.divIcon({
        html:
          `<img src="${first}" alt="shop logo" ` +
          `data-candidates="${joined}" data-idx="0" onerror="markerLogoFallback(this)" ` +
          `style="max-width:100% !important;max-height:100% !important;width:auto !important;height:auto !important;object-fit:contain !important;object-position:center center !important;display:block;margin:auto;">`,
        iconSize: [LOGO_MARKER_SIZE, LOGO_MARKER_SIZE],
        iconAnchor: [Math.round(LOGO_MARKER_SIZE / 2), LOGO_MARKER_SIZE],
        popupAnchor: [0, -LOGO_MARKER_SIZE],
        className: 'shop-logo-icon'
      });
    }

    /**
     * Decide which icon to use for a location:
     *  1) Use logo icon if present
     *  2) Else fall back to category pin icon
     *  3) Else default icon
     */
    function chooseMarkerIcon(loc) {
      // 1) Prefer logo icon if available
      const logoIcon = createLogoIcon(loc.logo);
      if (logoIcon) return logoIcon;

      // 2) Fall back to first matching category pin
      let icon = defaultIcon;
      for (const cat of categoryOptions) {
        if (cat === 'all' || cat === 'favourites') continue;
        if (loc[cat] && categoryIcons[cat]) {
          icon = categoryIcons[cat];
          break;
        }
      }
      return icon;
    }

    function popupLogoHtml(loc) {
      const candidates = logoCandidates(loc.logo);
      if (!candidates.length) return '';
      const joined = candidates.map(escapeHtmlAttr).join('|');
      const first = escapeHtmlAttr(candidates[0]);
      return `<img src="${first}" alt="${loc.name} logo"
                  data-candidates="${joined}" data-idx="0"
                  onerror="popupLogoFallback(this)"
                  style="width:${POPUP_LOGO_SIZE}px;height:${POPUP_LOGO_SIZE}px;object-fit:contain;display:block;margin:8px auto;border-radius:8px;background:white;">`;
    }

    // =========================================================
    // Rating stars
    // =========================================================

    /**
     * Convert a rating 0–5 to a "★★★☆☆" string.
     */
    function renderStars(rating) {
      const r = Math.max(0, Math.min(5, rating || 0));
      const full = '★'.repeat(r);
      const empty = '☆'.repeat(5 - r);
      return full + empty;
    }

    async function fetchDbIndex() {
      const res = await fetch('/browse?table=shops&limit=5000', { credentials: 'same-origin' });
      if (!res.ok) throw new Error(`DB index unavailable (${res.status})`);

      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const rows = [];

      doc.querySelectorAll('tbody tr').forEach(tr => {
        const tds = tr.querySelectorAll('td');
        if (tds.length < 4) return;
        const id = parseInt((tds[0].textContent || '').trim(), 10);
        if (!Number.isFinite(id)) return;
        rows.push({
          shop_id: id,
          name: (tds[1].textContent || '').trim(),
          city: (tds[2].textContent || '').trim(),
          shop_url: (tds[3].textContent || '').trim(),
        });
      });
      return rows;
    }

    function setDbStatus(text) {
      const el = document.getElementById('db-status');
      if (!el) return;
      if (!text) {
        el.textContent = '';
        el.style.display = 'none';
        return;
      }
      el.textContent = text;
      el.style.display = 'block';
    }

    function normaliseDbRow(raw) {
      const shopId = parseInt(raw && (raw.shop_id ?? raw.id), 10);
      if (!Number.isFinite(shopId)) return null;
      return {
        shop_id: shopId,
        name: ((raw && raw.name) || '').toString().trim(),
        city: ((raw && raw.city) || '').toString().trim(),
        shop_url: ((raw && (raw.shop_url || raw.website)) || '').toString().trim(),
      };
    }

    async function fetchDbIndexFromJson() {
      const candidates = [
        'shop_lookup.json',
        './shop_lookup.json',
        '/shop_lookup.json',
        'shops.json',
        './shops.json',
        '/shops.json',
      ];

      for (const url of candidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          let rows = [];

          if (Array.isArray(data)) {
            rows = data.map(normaliseDbRow).filter(Boolean);
          } else if (data && typeof data === 'object') {
            rows = Object.values(data).map(normaliseDbRow).filter(Boolean);
          }

          if (rows.length) return rows;
        } catch (_err) {
          // Try next candidate path.
        }
      }

      throw new Error('No JSON shop index available');
    }

    async function fetchStrainShopIdsFromFlask(q) {
      const res = await fetch(`/strain_lookup?q=${encodeURIComponent(q)}&limit=5000`, { credentials: 'same-origin' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const html = await res.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      const ids = new Set();

      doc.querySelectorAll('tbody tr').forEach(tr => {
        const link = tr.querySelector('a[href*="/shop/"]');
        if (!link) return;
        const id = extractShopIdFromHref(link.getAttribute('href') || '');
        if (id) ids.add(id);
      });
      return ids;
    }

    async function loadStrainIndexRows() {
      if (Array.isArray(strainIndexRows)) return strainIndexRows;

      const candidates = ['strain_index.json', './strain_index.json', '/strain_index.json'];
      for (const url of candidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          if (Array.isArray(data)) {
            strainIndexRows = data;
            return strainIndexRows;
          }
        } catch (_err) {
          // Try next candidate path.
        }
      }

      throw new Error('No strain index JSON available');
    }

    async function loadActiveOfferingsRows() {
      if (Array.isArray(activeOfferingsRows)) return activeOfferingsRows;

      const candidates = ['active_offerings.json', './active_offerings.json', '/active_offerings.json'];
      for (const url of candidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          if (Array.isArray(data)) {
            activeOfferingsRows = data;
            return activeOfferingsRows;
          }
        } catch (_err) {
          // Try next candidate path.
        }
      }

      throw new Error('No active offerings JSON available');
    }

    async function fetchStrainShopIdsFromJson(q) {
      const qNorm = normaliseText(q);
      if (!qNorm) return { ids: new Set(), nameCityKeys: new Set(), source: 'none' };

      try {
        const rows = await loadStrainIndexRows();
        const exactMatches = [];
        const partialMatches = [];

        rows.forEach(r => {
          const n = normaliseText((r && (r.strain_name_normalised || r.strain_name_display)) || '');
          if (!n) return;
          if (n === qNorm) {
            exactMatches.push(r);
          } else if (n.includes(qNorm)) {
            partialMatches.push(r);
          }
        });

        const matchedRows = exactMatches.length ? exactMatches : partialMatches;
        const ids = new Set();
        const nameCityKeys = new Set();
        matchedRows.forEach(r => {
          const shops = (r && Array.isArray(r.shops)) ? r.shops : [];
          shops.forEach(s => {
            const id = parseInt(s && s.shop_id, 10);
            if (Number.isFinite(id)) ids.add(id);
            const key = normaliseNameCityKey(s && s.shop_name, s && s.shop_city);
            if (key !== '|') nameCityKeys.add(key);
          });
        });
        return { ids, nameCityKeys, source: 'strain_index' };
      } catch (_strainErr) {
        // Fallback to active_offerings.json when strain_index.json is missing.
      }

      const rows = await loadActiveOfferingsRows();
      const exact = rows.filter(r => {
        const n = normaliseText((r && (r.strain_name_normalised || r.strain_name)) || '');
        return n === qNorm;
      });
      const partial = rows.filter(r => {
        const n = normaliseText((r && (r.strain_name_normalised || r.strain_name)) || '');
        return n.includes(qNorm);
      });
      const matchedRows = exact.length ? exact : partial;
      const ids = new Set();
      const nameCityKeys = new Set();
      matchedRows.forEach(r => {
        const id = parseInt(r && r.shop_id, 10);
        if (Number.isFinite(id)) ids.add(id);
        const key = normaliseNameCityKey(r && r.shop_name, r && r.shop_city);
        if (key !== '|') nameCityKeys.add(key);
      });
      return { ids, nameCityKeys, source: 'active_offerings' };
    }

    function dedupeAndSortStrainNames(names) {
      const byKey = new Map();
      (names || []).forEach(name => {
        const n = (name || '').toString().trim();
        const key = normaliseText(n);
        if (!key) return;
        if (!byKey.has(key)) byKey.set(key, n);
      });
      return Array.from(byKey.values()).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    }

    function pushStrainIntoIndex(indexMap, key, strainName) {
      const k = (key || '').toString().trim();
      const n = (strainName || '').toString().trim();
      if (!k || !n) return;
      if (!indexMap.has(k)) indexMap.set(k, []);
      indexMap.get(k).push(n);
    }

    function finalisePopupStrainMap(indexMap) {
      const out = new Map();
      indexMap.forEach((names, key) => {
        const deduped = dedupeAndSortStrainNames(names);
        if (deduped.length) out.set(key, deduped);
      });
      return out;
    }

    async function ensurePopupStrainIndex() {
      if (popupStrainIndexReady) return true;
      if (popupStrainIndexPromise) return popupStrainIndexPromise;

      popupStrainIndexPromise = (async () => {
        const byIdRaw = new Map();
        const byNameCityRaw = new Map();
        let sawRows = false;

        try {
          const rows = await loadStrainIndexRows();
          if (rows.length) sawRows = true;
          rows.forEach(r => {
            const strainName = ((r && (r.strain_name_display || r.strain_name_normalised)) || '').toString().trim();
            if (!strainName) return;
            const shops = (r && Array.isArray(r.shops)) ? r.shops : [];
            shops.forEach(s => {
              const id = parseInt(s && s.shop_id, 10);
              if (Number.isFinite(id)) {
                pushStrainIntoIndex(byIdRaw, String(id), strainName);
              }
              const key = normaliseNameCityKey(s && s.shop_name, s && s.shop_city);
              if (key !== '|') {
                pushStrainIntoIndex(byNameCityRaw, key, strainName);
              }
            });
          });
        } catch (_err) {
          // Optional source; keep going.
        }

        try {
          const rows = await loadActiveOfferingsRows();
          if (rows.length) sawRows = true;
          rows.forEach(r => {
            const strainName = ((r && (r.strain_name || r.strain_name_normalised)) || '').toString().trim();
            if (!strainName) return;
            const id = parseInt(r && r.shop_id, 10);
            if (Number.isFinite(id)) {
              pushStrainIntoIndex(byIdRaw, String(id), strainName);
            }
            const key = normaliseNameCityKey(r && r.shop_name, r && r.shop_city);
            if (key !== '|') {
              pushStrainIntoIndex(byNameCityRaw, key, strainName);
            }
          });
        } catch (_err) {
          // Optional source; keep going.
        }

        popupStrainsByShopId = finalisePopupStrainMap(byIdRaw);
        popupStrainsByNameCity = finalisePopupStrainMap(byNameCityRaw);
        popupStrainIndexReady = true;

        return sawRows || popupStrainsByShopId.size > 0 || popupStrainsByNameCity.size > 0;
      })()
        .finally(() => {
          popupStrainIndexPromise = null;
        });

      return popupStrainIndexPromise;
    }

    function isCoffeeShopLocation(loc) {
      if (!loc || typeof loc !== 'object') return false;
      if (typeof loc.Coffeeshop === 'boolean') return loc.Coffeeshop;
      const coffeeKey = Object.keys(loc).find(k => normaliseText(k) === 'coffeeshop');
      return coffeeKey ? !!loc[coffeeKey] : false;
    }

    function popupStrainContainerId(index) {
      return `popup-strains-${index}`;
    }

    function getPopupStrainsForLocation(loc) {
      if (!loc) return [];

      if (loc.db_shop_id) {
        const byId = popupStrainsByShopId.get(String(loc.db_shop_id));
        if (Array.isArray(byId) && byId.length) return byId;
      }

      const key = normaliseNameCityKey(loc.name, loc.city || '');
      const byNameCity = popupStrainsByNameCity.get(key);
      if (Array.isArray(byNameCity) && byNameCity.length) return byNameCity;

      return [];
    }

    async function refreshPopupStrainsForLocation(index) {
      const loc = locations[index];
      if (!loc || !isCoffeeShopLocation(loc)) return;

      const containerId = popupStrainContainerId(index);
      const container = document.getElementById(containerId);
      if (!container) return;

      container.innerHTML = '<p class="popup-strains-status">Loading strains...</p>';

      if (!loc.db_shop_id) {
        const dbOk = await ensureDbIntegration();
        if (dbOk) bindDbShopIdToLocation(loc);
      }

      await ensurePopupStrainIndex();

      const liveContainer = document.getElementById(containerId);
      if (!liveContainer) return;

      const strains = getPopupStrainsForLocation(loc);
      if (!strains.length) {
        liveContainer.innerHTML = '<p class="popup-strains-empty">No active strains found for this shop.</p>';
        return;
      }

      const countText = `${strains.length} strain${strains.length === 1 ? '' : 's'} available`;
      const itemsHtml = strains.map(name => `<li>${escapeHtml(name)}</li>`).join('');
      liveContainer.innerHTML =
        `<p class="popup-strains-count">${countText}</p>` +
        `<ul class="popup-strains-list">${itemsHtml}</ul>`;
    }

    async function fetchActiveStrainNames() {
      try {
        const rows = await loadStrainIndexRows();
        const names = rows.map(r => (r && (r.strain_name_display || r.strain_name_normalised)) || '');
        const out = dedupeAndSortStrainNames(names);
        if (out.length) return out;
      } catch (_err) {
        // Fallback below.
      }

      const rows = await loadActiveOfferingsRows();
      const names = rows.map(r => (r && (r.strain_name || r.strain_name_normalised)) || '');
      return dedupeAndSortStrainNames(names);
    }

    function updateStrainListSelection() {
      const key = normaliseText(strainFilterText || '');
      document.querySelectorAll('#strain-list .strain-item').forEach(btn => {
        const btnKey = normaliseText(btn.getAttribute('data-strain') || '');
        btn.classList.toggle('active', key !== '' && btnKey === key);
      });
    }

    function renderStrainList() {
      const listEl = document.getElementById('strain-list');
      const searchEl = document.getElementById('strain-list-search');
      if (!listEl || !searchEl) return;

      const q = normaliseText(searchEl.value || '');
      const names = activeStrainNames.filter(name => !q || normaliseText(name).includes(q));
      listEl.innerHTML = '';

      if (!names.length) {
        listEl.innerHTML = '<div class="strain-empty">No strains found.</div>';
        return;
      }

      const frag = document.createDocumentFragment();
      names.forEach(name => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'strain-item';
        btn.setAttribute('data-strain', name);
        btn.textContent = name;
        frag.appendChild(btn);
      });
      listEl.appendChild(frag);
      updateStrainListSelection();
    }

    async function populateStrainListPanel() {
      const statusEl = document.getElementById('strain-list-status');
      const listEl = document.getElementById('strain-list');
      if (!statusEl || !listEl) return;

      if (!activeStrainNames.length) {
        statusEl.textContent = 'Loading active strains...';
        listEl.innerHTML = '';
        try {
          activeStrainNames = await fetchActiveStrainNames();
        } catch (_err) {
          statusEl.textContent = 'Strain list unavailable';
          listEl.innerHTML = '<div class="strain-empty">Unable to load strain data.</div>';
          return;
        }
      }

      statusEl.textContent = `${activeStrainNames.length} active strains`;
      renderStrainList();
    }

    function setStrainListVisible(show) {
      strainListVisible = !!show;
      const panel = document.getElementById('strain-list-panel');
      const toggleBtn = document.getElementById('toggle-strain-list');
      if (panel) panel.style.display = strainListVisible ? 'block' : 'none';
      if (toggleBtn) toggleBtn.textContent = strainListVisible ? 'Hide strains' : 'Show strains';
      if (strainListVisible) {
        populateStrainListPanel();
      }
    }

    async function ensureDbIntegration() {
      if (dbIntegrationReady) return true;
      let rows = [];

      try {
        rows = await fetchDbIndex();
        dbIntegrationSource = 'flask';
        dbRouteLinksEnabled = true;
      } catch (_flaskErr) {
        try {
          rows = await fetchDbIndexFromJson();
          dbIntegrationSource = 'json';
          dbRouteLinksEnabled = false;
        } catch (_jsonErr) {
          dbIntegrationReady = false;
          dbIntegrationSource = 'none';
          dbRouteLinksEnabled = false;
          setDbStatus('');
          return false;
        }
      }

      dbByPath = new Map();
      dbByNameCity = new Map();
      const nameCounts = new Map();

      rows.forEach(r => {
        const p = normaliseUrlPath(r.shop_url);
        if (p) dbByPath.set(p, r.shop_id);
        const nc = normaliseNameCityKey(r.name, r.city);
        if (nc !== '|') dbByNameCity.set(nc, r.shop_id);
        const nk = normaliseText(r.name);
        nameCounts.set(nk, (nameCounts.get(nk) || 0) + 1);
      });

      dbByUniqueName = new Map();
      rows.forEach(r => {
        const nk = normaliseText(r.name);
        if ((nameCounts.get(nk) || 0) === 1) {
          dbByUniqueName.set(nk, r.shop_id);
        }
      });

      dbIntegrationReady = true;
      if (dbIntegrationSource === 'flask') {
        setDbStatus(`DB links: connected (${rows.length} shops indexed)`);
      } else {
        // No warning banner for JSON/static mode.
        setDbStatus('');
      }
      return true;
    }

    function bindDbShopIdToLocation(loc) {
      let shopId = null;

      const byPath = normaliseUrlPath(loc.website);
      if (byPath && dbByPath.has(byPath)) {
        shopId = dbByPath.get(byPath);
      }

      if (!shopId) {
        const nc = normaliseNameCityKey(loc.name, loc.city || '');
        if (dbByNameCity.has(nc)) {
          shopId = dbByNameCity.get(nc);
        }
      }

      if (!shopId) {
        const nk = normaliseText(loc.name);
        if (dbByUniqueName.has(nk)) {
          shopId = dbByUniqueName.get(nk);
        }
      }

      loc.db_shop_id = shopId || null;
    }

    async function applyStrainFilter() {
      const input = document.getElementById('strain-filter');
      const status = document.getElementById('strain-status');
      if (!input || !status) return;

      const q = (input.value || '').trim();
      if (!q) {
        strainFilterText = '';
        strainAllowedShopIds = null;
        strainAllowedNameCityKeys = null;
        status.textContent = 'Strain filter: off';
        updateDestinationDropdown();
        updateDistanceInfo();
        updateMarkers();
        updateStrainListSelection();
        return;
      }

      const dbOk = await ensureDbIntegration();

      // If DB index is available, link shop ids now.
      if (dbOk) {
        locations.forEach(bindDbShopIdToLocation);
      }

      try {
        let result;
        if (dbRouteLinksEnabled) {
          try {
            const ids = await fetchStrainShopIdsFromFlask(q);
            result = { ids, nameCityKeys: new Set(), source: 'flask' };
          } catch (_err) {
            // Flask endpoint not available: fall back to JSON index.
            dbRouteLinksEnabled = false;
            result = await fetchStrainShopIdsFromJson(q);
          }
        } else {
          result = await fetchStrainShopIdsFromJson(q);
        }

        strainFilterText = q;
        strainAllowedShopIds = result.ids;
        strainAllowedNameCityKeys = result.nameCityKeys.size ? result.nameCityKeys : null;
        const matchedCount = locations.filter((loc, idx) => {
          const key = normaliseNameCityKey(loc.name, loc.city || '');
          const byId = loc.db_shop_id && strainAllowedShopIds.has(loc.db_shop_id);
          const byKey = strainAllowedNameCityKeys && strainAllowedNameCityKeys.has(key);
          return byId || byKey;
        }).length;
        status.textContent = `Strain filter: "${q}" (${matchedCount} shops)`;
        updateDestinationDropdown();
        updateDistanceInfo();
        updateMarkers();
        updateStrainListSelection();
      } catch (err) {
        status.textContent = 'Strain filter unavailable: missing JSON index files';
      }
    }

    function clearStrainFilter() {
      const input = document.getElementById('strain-filter');
      const status = document.getElementById('strain-status');
      if (input) input.value = '';
      strainFilterText = '';
      strainAllowedShopIds = null;
      strainAllowedNameCityKeys = null;
      if (status) status.textContent = 'Strain filter: off';
      updateDestinationDropdown();
      updateDistanceInfo();
      updateMarkers();
      updateStrainListSelection();
    }

    // =========================================================
    // CSV loading
    // =========================================================

    function normaliseDiscoveredCsvPath(pathLike) {
      const raw = (pathLike || '').toString().trim();
      if (!raw) return '';

      let pathPart = raw;
      const isAbsoluteUrl = /^[a-z][a-z0-9+.-]*:\/\//i.test(raw);
      if (isAbsoluteUrl) {
        try {
          pathPart = (new URL(raw)).pathname || '';
        } catch (_err) {
          pathPart = raw;
        }
      }

      // Normalize separators and remove query/hash fragments.
      let p = pathPart
        .replace(/\\/g, '/')
        .split('#')[0]
        .split('?')[0]
        .trim()
        .replace(/^\.\/+/, '')
        .replace(/^\/+/, '');

      if (!p || !/\.csv$/i.test(p)) return '';

      // If the path includes a locations/ segment anywhere, keep only from there.
      const lower = p.toLowerCase();
      const idx = lower.lastIndexOf('locations/');
      if (idx >= 0) {
        p = p.slice(idx);
      }

      return p;
    }

    function ensureLocationsPrefix(pathLike) {
      const p = (pathLike || '').toString().replace(/^\/+/, '');
      if (!p) return '';
      return p.toLowerCase().startsWith('locations/') ? p : `locations/${p}`;
    }

    function pickFirstCsvPath(paths) {
      const out = Array.from(new Set(
        (paths || [])
          .map(p => (p || '').toString().trim())
          .filter(p => p && /\.csv$/i.test(p))
      ));
      out.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      return out[0] || null;
    }

    function canonicalCsvPath(pathLike) {
      const normalised = normaliseDiscoveredCsvPath(pathLike);
      if (normalised) return ensureLocationsPrefix(normalised);
      return (pathLike || '').toString().trim();
    }

    function csvLabelFromPath(pathLike) {
      const p = canonicalCsvPath(pathLike);
      if (!p) return '';
      const parts = p.split('/');
      return parts[parts.length - 1] || p;
    }

    function renderCsvSwitchSelect(selectedPathLike) {
      const wrap = document.getElementById('csv-switch-wrap');
      const select = document.getElementById('csv-switch-select');
      if (!wrap || !select) return;

      select.innerHTML = '';

      if (!Array.isArray(discoveredCsvPaths) || discoveredCsvPaths.length <= 1) {
        wrap.style.display = 'none';
        return;
      }

      wrap.style.display = 'block';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.text = 'Select CSV...';
      placeholder.disabled = true;
      select.appendChild(placeholder);

      discoveredCsvPaths.forEach(path => {
        const opt = document.createElement('option');
        opt.value = path;
        opt.text = csvLabelFromPath(path);
        select.appendChild(opt);
      });

      const selectedPath = canonicalCsvPath(selectedPathLike);
      if (selectedPath && discoveredCsvPaths.includes(selectedPath)) {
        select.value = selectedPath;
      } else if (currentCsvPath && discoveredCsvPaths.includes(currentCsvPath)) {
        select.value = currentCsvPath;
      } else {
        select.value = '';
      }
    }

    function setDiscoveredCsvPaths(paths, selectedPathLike) {
      discoveredCsvPaths = Array.from(new Set(
        (paths || [])
          .map(canonicalCsvPath)
          .filter(p => p && /\.csv$/i.test(p))
      )).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

      renderCsvSwitchSelect(selectedPathLike);
    }

    function buildCsvPathVariants(pathLike) {
      const raw = (pathLike || '').toString().trim();
      if (!raw) return [];

      const out = [];
      const seen = new Set();
      const pushUnique = p => {
        const v = (p || '').toString().trim();
        if (!v || seen.has(v)) return;
        seen.add(v);
        out.push(v);
      };

      pushUnique(raw);

      const isAbsoluteUrl = /^[a-z][a-z0-9+.-]*:\/\//i.test(raw);
      const isDataUrl = raw.toLowerCase().startsWith('data:');
      if (isAbsoluteUrl || isDataUrl) {
        return out;
      }

      const stripped = raw.replace(/^\.\/+/, '').replace(/^\/+/, '');
      if (!stripped) {
        return out;
      }

      pushUnique(stripped);
      pushUnique(`./${stripped}`);
      pushUnique(`/${stripped}`);

      if (stripped.toLowerCase().startsWith('locations/')) {
        const withoutPrefix = stripped.slice('locations/'.length);
        pushUnique(withoutPrefix);
        pushUnique(`./${withoutPrefix}`);
        pushUnique(`/${withoutPrefix}`);
      } else {
        pushUnique(`locations/${stripped}`);
        pushUnique(`./locations/${stripped}`);
        pushUnique(`/locations/${stripped}`);
      }

      return out;
    }

    async function discoverCsvPathsInLocations() {
      const jsonCandidates = ['locations/index.json', './locations/index.json', '/locations/index.json'];
      for (const url of jsonCandidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const data = await res.json();
          const files = Array.isArray(data)
            ? data
            : (data && Array.isArray(data.files) ? data.files : []);
          const csvPaths = files
            .map(normaliseDiscoveredCsvPath)
            .filter(Boolean)
            .map(ensureLocationsPrefix);
          if (csvPaths.length) {
            return Array.from(new Set(csvPaths))
              .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
          }
        } catch (_err) {
          // Try next discovery source.
        }
      }

      const dirCandidates = ['locations/', './locations/', '/locations/'];
      for (const url of dirCandidates) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) continue;
          const html = await res.text();
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const base = new URL(url, window.location.href);
          const csvPaths = [];

          doc.querySelectorAll('a[href]').forEach(a => {
            const href = (a.getAttribute('href') || '').trim();
            if (!href) return;
            let resolved;
            try {
              resolved = new URL(href, base);
            } catch (_err) {
              return;
            }
            if (resolved.origin !== window.location.origin) return;
            const p = (resolved.pathname || '').replace(/^\/+/, '');
            if (!/\.csv$/i.test(p)) return;
            csvPaths.push(p);
          });

          const inLocations = csvPaths
            .map(normaliseDiscoveredCsvPath)
            .filter(p => p.toLowerCase().startsWith('locations/'));
          if (inLocations.length) {
            return Array.from(new Set(inLocations))
              .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
          }
        } catch (_err) {
          // Try next discovery source.
        }
      }

      return [];
    }

    async function parseCsvInput(input, parseOptions) {
      return new Promise((resolve, reject) => {
        Papa.parse(input, {
          header: true,
          skipEmptyLines: true,
          ...(parseOptions || {}),
          complete: async results => {
            const hasData = results && Array.isArray(results.data) && results.data.length > 0;
            if (!hasData) {
              reject(new Error('No valid rows found in CSV.'));
              return;
            }
            resolve(results.data);
          },
          error: err => {
            reject(err || new Error('CSV parsing failed.'));
          }
        });
      });
    }

    async function applyCsvRows(rows) {
      // Map each CSV row into a location object.
      // NOTE:
      //  - "logo" is optional.
      //  - Any additional Y/N columns become boolean flags (categories).
      locations = rows.map(r => {
        const obj = {
          name: r.name,
          city: r.city || '',
          coords: [parseFloat(r.lat), parseFloat(r.lng)],
          website: r.website,
          logo: r.logo,
          visited: false,
          rating: 0,
          db_shop_id: null
        };

        // Parse visited flag (Y/N)
        if (typeof r.visited === 'string') {
          obj.visited = r.visited.trim().toLowerCase() === 'y';
        }

        // Parse rating as integer 1-5 (anything invalid -> 0 = no rating)
        if (r.rating !== undefined && r.rating !== null && r.rating !== '') {
          const pr = parseInt(r.rating, 10);
          if (!isNaN(pr)) {
            obj.rating = Math.max(1, Math.min(5, pr));
          }
        }

        // Parse other boolean Y/N fields as category flags.
        Object.entries(r).forEach(([k, v]) => {
          if (['name','lat','lng','website','visited','rating','logo'].includes(k)) return;
          if (typeof v === 'string' && v.trim() !== '') {
            obj[k] = v.toLowerCase() === 'y';
          }
        });

        return obj;
      });

      if (!locations.length) {
        throw new Error('No valid rows found in CSV.');
      }

      resetMapState();

      // Reset per-CSV UI/filter state.
      strainFilterText = '';
      strainAllowedShopIds = null;
      strainAllowedNameCityKeys = null;
      setStrainListVisible(false);
      const strainInput = document.getElementById('strain-filter');
      const strainStatus = document.getElementById('strain-status');
      const strainSearch = document.getElementById('strain-list-search');
      const strainList = document.getElementById('strain-list');
      const strainListStatus = document.getElementById('strain-list-status');
      if (strainInput) strainInput.value = '';
      if (strainStatus) strainStatus.textContent = 'Strain filter: off';
      if (strainSearch) strainSearch.value = '';
      if (strainList) strainList.innerHTML = '';
      if (strainListStatus) strainListStatus.textContent = 'Load CSV first.';
      const eta = document.getElementById('time-estimate');
      const distance = document.getElementById('distance-info');
      if (eta) eta.textContent = 'ETA: --';
      if (distance) distance.textContent = '';

      // Link CSV shops to DB shop ids (if backend is reachable).
      const dbOk = await ensureDbIntegration();
      if (dbOk) {
        locations.forEach(bindDbShopIdToLocation);
      }

      // Determine which keys are boolean flags (Y/N) and not special fields.
      categoryOptions = Object.keys(locations[0]).filter(
        key =>
          !['name','coords','website','visited','rating','logo'].includes(key) &&
          typeof locations[0][key] === 'boolean'
      );

      // Add synthetic categories.
      categoryOptions.unshift('favourites');
      categoryOptions.unshift('all');

      // Default to showing all locations.
      selectedCategories = ['all'];

      initCategoryIcons();
      populateCategorySelect();

      document.getElementById('map').style.display = 'block';
      document.getElementById('ui-toggles').style.display = 'block';
      setUploadPanelState('', '', false);

      // Start with all panels hidden.
      setControlsVisible(false);
      setDirectionsVisible(false);
      setStrainListVisible(false);

      const menuDropdown = document.getElementById('menu-dropdown');
      if (menuDropdown) menuDropdown.open = false;

      initApp();
    }

    async function loadCsvFromFile(file) {
      const rows = await parseCsvInput(file);
      await applyCsvRows(rows);

      const lowerName = (file && file.name) ? file.name.toLowerCase() : '';
      const matchedPath = discoveredCsvPaths.find(p => {
        const lp = p.toLowerCase();
        return lp === lowerName || lp.endsWith(`/${lowerName}`);
      }) || '';

      currentCsvPath = matchedPath;
      renderCsvSwitchSelect(currentCsvPath);
    }

    async function loadFirstCsvFromDirectoryHandle(dirHandle) {
      if (!dirHandle || typeof dirHandle.entries !== 'function') {
        throw new Error('Folder picker is not available.');
      }

      const csvFileNames = [];
      for await (const [, handle] of dirHandle.entries()) {
        if (handle && handle.kind === 'file' && /\.csv$/i.test(handle.name || '')) {
          csvFileNames.push(handle.name);
        }
      }

      csvFileNames.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      const firstCsv = csvFileNames[0];
      if (!firstCsv) {
        throw new Error('No .csv files found in selected folder.');
      }

      const fileHandle = await dirHandle.getFileHandle(firstCsv);
      const file = await fileHandle.getFile();
      await loadCsvFromFile(file);
      return firstCsv;
    }

    async function loadCsvFromPath(path) {
      const csvPath = (path || '').toString().trim();
      if (!csvPath) throw new Error('CSV path is empty.');

      const variants = buildCsvPathVariants(csvPath);
      const attempts = [];

      for (const candidate of variants) {
        try {
          const rows = await parseCsvInput(candidate, { download: true });
          await applyCsvRows(rows);
          currentCsvPath = canonicalCsvPath(candidate);
          renderCsvSwitchSelect(currentCsvPath);
          return;
        } catch (err) {
          const reason = (err && err.message) ? err.message : 'unknown error';
          attempts.push(`${candidate}: ${reason}`);
        }
      }

      if (window.location.protocol === 'file:') {
        throw new Error(
          'Browser security blocks auto-loading local files from file://. ' +
          'Use "Choose CSV manually", "Choose locations folder", or run a local HTTP server.'
        );
      }

      throw new Error(attempts.slice(0, 3).join(' | ') || 'Could not fetch CSV.');
    }

    async function bootstrapInitialCsvLoad() {
      setUploadPanelState('Loading locations CSV', 'Looking for the first CSV in locations/...', false);

      const csvPaths = await discoverCsvPathsInLocations();
      const firstCsv = pickFirstCsvPath(csvPaths);
      if (!firstCsv) {
        if (window.location.protocol === 'file:') {
          setUploadPanelState(
            'Could not auto-load CSV on file://',
            'Browser security blocks folder discovery in local-file mode. Choose CSV manually, choose locations folder, or run a local server.',
            true
          );
          return;
        }

        setUploadPanelState(
          'No CSV found in locations/',
          'Add a .csv file to locations/ or choose one manually.',
          true
        );
        return;
      }

      setDiscoveredCsvPaths(csvPaths, firstCsv);

      try {
        await loadCsvFromPath(firstCsv);
      } catch (err) {
        const reason = err && err.message ? err.message : 'unknown error';
        setUploadPanelState(
          'Could not load CSV from locations/',
          `Failed to load ${firstCsv} (${reason}). Choose one manually.`,
          true
        );
      }
    }

    document.getElementById('manual-csv-btn').addEventListener('click', () => {
      const input = document.getElementById('file-input');
      if (input) input.click();
    });

    document.getElementById('folder-csv-btn').addEventListener('click', async () => {
      if (typeof window.showDirectoryPicker !== 'function') {
        setUploadPanelState(
          'Folder picker not supported',
          'Use "Choose CSV manually" or run the page on a local HTTP server.',
          true
        );
        return;
      }

      try {
        setUploadPanelState(
          'Loading CSV from selected folder',
          'Scanning for the first .csv file...',
          false
        );
        const dirHandle = await window.showDirectoryPicker({ mode: 'read' });
        await loadFirstCsvFromDirectoryHandle(dirHandle);
      } catch (err) {
        if (err && err.name === 'AbortError') {
          setUploadPanelState(
            'CSV not loaded yet',
            'Choose CSV manually or choose locations folder.',
            true
          );
          return;
        }
        const reason = err && err.message ? err.message : 'unknown error';
        setUploadPanelState('Could not load CSV folder', `Error: ${reason}`, true);
      }
    });

    document.getElementById('change-csv-btn').addEventListener('click', () => {
      const menuDropdown = document.getElementById('menu-dropdown');
      if (menuDropdown) menuDropdown.open = false;

      if (discoveredCsvPaths.length > 1) {
        setControlsVisible(true);
        const csvSelect = document.getElementById('csv-switch-select');
        if (csvSelect) csvSelect.focus();
        return;
      }

      const input = document.getElementById('file-input');
      if (input) input.click();
    });

    document.getElementById('csv-switch-select').addEventListener('change', async e => {
      const selectedPath = canonicalCsvPath(e.target.value);
      if (!selectedPath || selectedPath === currentCsvPath) return;

      setUploadPanelState('Loading locations CSV', `Loading ${csvLabelFromPath(selectedPath)}...`, false);
      try {
        await loadCsvFromPath(selectedPath);
      } catch (err) {
        const reason = err && err.message ? err.message : 'unknown error';
        setUploadPanelState(
          'Could not load selected indexed CSV',
          `Failed to load ${selectedPath} (${reason}).`,
          true
        );
        renderCsvSwitchSelect(currentCsvPath);
      }
    });

    document.getElementById('file-input').addEventListener('change', async e => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      setUploadPanelState('Loading selected CSV', `Loading ${file.name}...`, false);
      try {
        await loadCsvFromFile(file);
      } catch (err) {
        const reason = err && err.message ? err.message : 'unknown error';
        setUploadPanelState('Could not load selected CSV', `Error: ${reason}`, true);
      } finally {
        e.target.value = '';
      }
    });

    // =========================================================
    // Map initialisation
    // =========================================================

    /**
     * Set up the map, markers, routing, and event listeners.
     */
    function initApp() {
      // Create the Leaflet map
      map = L.map('map').setView([0, 0], 2);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OSM contributors'
      }).addTo(map);

      // Create a marker for each location
      locations.forEach((loc, i) => {
        // NEW: choose icon, preferring logo if available
        const icon = chooseMarkerIcon(loc);
        const isCoffeeShop = isCoffeeShopLocation(loc);

        // Popup logo supports multiple fallback paths.
        const logoHtml = popupLogoHtml(loc);

        const websitePreviewHtml = isCoffeeShop
          ? ''
          : (
              `<a href="${loc.website}" target="_blank">` +
                `<img src="https://image.thum.io/get/width/300/${loc.website}" ` +
                     `alt="Thumbnail of ${loc.name}" ` +
                     `style="width:100%;height:auto;margin:8px 0;">` +
              `</a><br>`
            );

        const popupStrainsHtml = isCoffeeShop
          ? (
              `<div class="popup-strains-box" id="${popupStrainContainerId(i)}">` +
                `<p class="popup-strains-status">Loading strains...</p>` +
              `</div>`
            )
          : '';

        // If this CSV shop maps to a DB shop, show quick links.
        const dbMenuLinks = (dbRouteLinksEnabled && loc.db_shop_id)
          ? (
              `<a href="/shop/${loc.db_shop_id}/digitised" target="_blank">Menu (database)</a><br>` +
              `<a href="/shop/${loc.db_shop_id}" target="_blank">Edit menu entry</a><br>`
            )
          : '';

        const marker = L.marker(loc.coords, { icon: icon, zIndexOffset: 1000 })
          .addTo(map)
          .bindPopup(
            `<strong>${loc.name}</strong><br>` +
            logoHtml +
            websitePreviewHtml +
            popupStrainsHtml +
            dbMenuLinks +
            `<a href="${loc.website}" target="_blank">Website</a><br>` +
            `<a href="https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${loc.coords[0]},${loc.coords[1]}" target="_blank">Street View</a><br>` +
            `<button class="fav-btn" data-index="${i}">` +
              `${favorites.includes(i) ? 'Remove from Favorites' : 'Add to Favorites'}` +
            `</button>` +
            `<br>` +
            `<label><input type="checkbox" class="visited-checkbox" data-index="${i}" ${loc.visited ? 'checked' : ''}> Visited</label><br>` +
            `<span class="rating-label">Rating: </span>` +
            `<span class="rating-stars" data-index="${i}" data-rating="${loc.rating}">${renderStars(loc.rating)}</span>`
          )
          .on('click', function () {
            this.openPopup();
          })
          .on('popupopen', () => {
            if (isCoffeeShop) {
              refreshPopupStrainsForLocation(i);
            }
          });

        markers[i] = marker;
      });

      // Fit map view to show all markers
      if (markers.length > 0) {
        const group = L.featureGroup(markers);
        map.fitBounds(group.getBounds(), { padding: [20, 20] });
      }

      updateDestinationDropdown();
      updateDistanceInfo();
      updateMarkers();

      // Recalculate route if mode changes.
      const modeSelect = document.getElementById('mode');
      if (modeSelect) {
        modeSelect.onchange = () => {
          if (lastPosition) {
            findRoute({ coords: { latitude: lastPosition[0], longitude: lastPosition[1] } });
          }
        };
      }

      // Change destination from dropdown.
      const destinationSelect = document.getElementById('destination-select');
      if (destinationSelect) {
        destinationSelect.onchange = () => {
          const destIndex = getSelectedDestinationIndex();
          if (destIndex === null) {
            clearRouteUi();
            updateDistanceInfo();
            return;
          }

          if (lastPosition) {
            findRoute({ coords: { latitude: lastPosition[0], longitude: lastPosition[1] } });

            const destCoords = locations[destIndex].coords;
            map.panTo(destCoords);
            markers[destIndex].openPopup();
            markers[destIndex].bringToFront();
          }
          updateDistanceInfo();
        };
      }

      // Watch user location via Geolocation API
      if (navigator.geolocation) {
        if (geolocationWatchId !== null) {
          try {
            navigator.geolocation.clearWatch(geolocationWatchId);
          } catch (_err) {
            // Ignore if watch id is stale.
          }
          geolocationWatchId = null;
        }

        geolocationWatchId = navigator.geolocation.watchPosition(
          p => {
            const np = [p.coords.latitude, p.coords.longitude];

            // Only update if moved a reasonable distance
            if (!lastPosition || haversineDistance(lastPosition, np) > 10) {
              lastPosition = np;

              const initialIndex = getSelectedDestinationIndex();
              if (initialIndex !== null) {
                findRoute(p);

                // On first route, focus initial destination marker
                const initialCoords = locations[initialIndex].coords;
                map.panTo(initialCoords);
                markers[initialIndex].openPopup();
                markers[initialIndex].bringToFront();
              } else {
                clearRouteUi();
              }
              updateDestinationDropdown();
              updateDistanceInfo();
            }
          },
          err => alert(err.message),
          { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
        );
      } else {
        alert('Geolocation not supported.');
      }
    }

    // =========================================================
    // Distance helpers
    // =========================================================

    /**
     * Haversine distance between two [lat,lng] in meters.
     */
    function haversineDistance([a1, a2], [b1, b2]) {
      const R = 6371e3;
      const t = d => d * Math.PI / 180;
      const φ1 = t(a1);
      const φ2 = t(b1);
      const Δφ = t(b1 - a1);
      const Δλ = t(b2 - a2);

      const a = Math.sin(Δφ / 2) ** 2 +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) ** 2;

      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // =========================================================
    // Routing
    // =========================================================

    /**
     * Draw a route from user position to selected destination,
     * and populate ETA + text directions.
     */
    function getSelectedDestinationIndex() {
      const sel = document.getElementById('destination-select');
      if (!sel) return null;
      const i = parseInt(sel.value, 10);
      if (isNaN(i) || i < 0 || i >= locations.length) {
        return null;
      }
      return i;
    }

    function clearRouteUi() {
      if (routingControl && map) {
        try {
          map.removeControl(routingControl);
        } catch (_err) {
          // Ignore if already removed.
        }
      }
      routingControl = null;

      const eta = document.getElementById('time-estimate');
      if (eta) eta.textContent = 'ETA: --';

      const ins = document.getElementById('instructions');
      if (ins) ins.innerHTML = '';
    }

    function findRoute(position) {
      const userCoords = [position.coords.latitude, position.coords.longitude];
      const di = getSelectedDestinationIndex();
      if (di === null) {
        clearRouteUi();
        return;
      }
      const destCoords = locations[di].coords;

      if (routingControl) map.removeControl(routingControl);

      routingControl = L.Routing.control({
        waypoints: [L.latLng(...userCoords), L.latLng(...destCoords)],
        router: L.Routing.osrmv1({
          serviceUrl: 'https://router.project-osrm.org/route/v1',
          profile: document.getElementById('mode').value
        }),
        fitSelectedRoutes: false,
        addWaypoints: false,
        show: false
      }).addTo(map);

      routingControl.on('routesfound', e => {
        const summary = e.routes[0].summary;
        const mode = document.getElementById('mode').value;
        let totalSec;

        // Different speeds for different modes
        if (mode === 'walking') {
          // Walking: ~5 km/h => 1.3889 m/s
          totalSec = summary.totalDistance / 1.3889;
        } else if (mode === 'cycling') {
          // Cycling: ~15 km/h => 4.1667 m/s
          totalSec = summary.totalDistance / 4.1667;
        } else {
          // Driving: use OSRM's estimated time
          totalSec = summary.totalTime;
        }

        const hours   = Math.floor(totalSec / 3600);
        const minutes = Math.floor((totalSec % 3600) / 60);
        const seconds = Math.floor(totalSec % 60);

        let eta = '';
        if (hours > 0)   eta += hours + 'h ';
        if (minutes > 0) eta += minutes + 'm ';
        eta += seconds + 's';

        document.getElementById('time-estimate').textContent = 'ETA: ' + eta;

        const ins = document.getElementById('instructions');
        ins.innerHTML = '<h4>Directions</h4>';
        const ol = document.createElement('ol');
        e.routes[0].instructions.forEach(i => {
          const li = document.createElement('li');
          li.textContent = i.text;
          ol.appendChild(li);
        });
        ins.appendChild(ol);

        updateDistanceInfo();
      });
    }

    // =========================================================
    // Category filters (checkbox UI)
    // =========================================================

    /**
     * Build the list of category checkboxes.
     */
    function populateCategorySelect() {
      const container = document.getElementById('category-filters');
      if (!container) return;

      container.innerHTML = '<span>Categories:</span><br>';

      const cats = selectedCategories || [];

      categoryOptions.forEach(cat => {
        const id = 'cat-' + cat;
        const labelEl = document.createElement('label');
        labelEl.style.display = 'block';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.className = 'category-checkbox';
        input.value = cat;
        input.id = id;

        // Check the box if it's currently selected, or default to 'all'
        if ((cats.length === 0 && cat === 'all') || cats.includes(cat)) {
          input.checked = true;
        }

        const niceName = cat.charAt(0).toUpperCase() + cat.slice(1);
        labelEl.appendChild(input);
        labelEl.appendChild(document.createTextNode(' ' + niceName));
        container.appendChild(labelEl);
      });

      updateNearestLabel();
    }

    /**
     * Update the "Nearest ..." button label based on selected categories.
     */
    function updateNearestLabel() {
      const btn = document.getElementById('nearest-btn');
      if (!btn) return;

      const cats = selectedCategories || [];
      let label = 'Location';

      // If nothing selected or 'all' selected, keep generic label
      if (cats.length === 0 || cats.includes('all')) {
        label = 'Location';
      } else {
        const nonAll = cats.filter(c => c !== 'all');
        // Only favourites selected
        if (nonAll.length === 1 && nonAll[0] === 'favourites') {
          label = 'Favourite';
        } else if (nonAll.length === 1 && nonAll[0] !== 'favourites') {
          const cat = nonAll[0];
          label = cat.charAt(0).toUpperCase() + cat.slice(1);
        } else {
          // Multiple specific categories selected
          label = 'Location';
        }
      }

      btn.textContent = 'Nearest ' + label;
    }

    /**
     * Check whether a location passes the currently selected category filters.
     */
    function passesCategoryFilter(loc, index) {
      const cats = (Array.isArray(selectedCategories) && selectedCategories.length > 0)
        ? selectedCategories.slice()
        : ['all'];

      let categoryOk = true;
      if (!cats.includes('all')) {
        const isFav = favorites.includes(index);
        const nonSpecial = cats.filter(c => c !== 'favourites');

        // Base match: by category flags from CSV
        let baseMatch;
        if (nonSpecial.length === 0) {
          // No normal categories selected (only 'favourites')
          baseMatch = true;
        } else {
          baseMatch = nonSpecial.some(cat => loc[cat]);
        }

        // If 'favourites' is selected, require it as well
        if (cats.includes('favourites')) {
          categoryOk = isFav && baseMatch;
        } else {
          categoryOk = baseMatch;
        }
      }

      if (!categoryOk) {
        return false;
      }

      // Optional DB strain filter: include only DB-mapped shops in the allowed set.
      if (strainAllowedShopIds !== null || strainAllowedNameCityKeys !== null) {
        if (loc.db_shop_id && strainAllowedShopIds && strainAllowedShopIds.has(loc.db_shop_id)) {
          return true;
        }
        if (strainAllowedNameCityKeys) {
          const key = normaliseNameCityKey(loc.name, loc.city || '');
          return strainAllowedNameCityKeys.has(key);
        }
        return false;
      }

      return true;
    }

    // Handle changes to category checkboxes (multi-select categories)
    document.getElementById('category-filters').addEventListener('change', e => {
      if (!e.target.classList.contains('category-checkbox')) return;

      const cat = e.target.value;
      const checked = e.target.checked;

      let current = Array.isArray(selectedCategories) ? selectedCategories.slice() : [];

      if (checked) {
        if (cat === 'all') {
          // 'All' overrides everything else
          current = ['all'];
          // Uncheck all other boxes
          document.querySelectorAll('.category-checkbox').forEach(cb => {
            if (cb.value !== 'all') cb.checked = false;
          });
        } else {
          // Add this category, remove 'all' if present
          current = current.filter(c => c !== 'all');
          if (!current.includes(cat)) current.push(cat);
          // Uncheck 'all'
          const allCb = document.querySelector('.category-checkbox[value="all"]');
          if (allCb) allCb.checked = false;
        }
      } else {
        // Removing a category
        current = current.filter(c => c !== cat);
        // If nothing left, default back to 'all'
        if (current.length === 0) {
          current = ['all'];
          const allCb = document.querySelector('.category-checkbox[value="all"]');
          if (allCb) allCb.checked = true;
        }
      }

      selectedCategories = current;
      updateNearestLabel();
      updateDestinationDropdown();
      updateDistanceInfo();
      updateMarkers();
    });

    document.getElementById('apply-strain-btn').addEventListener('click', async () => {
      await applyStrainFilter();
    });

    document.getElementById('clear-strain-btn').addEventListener('click', () => {
      clearStrainFilter();
    });

    document.getElementById('strain-filter').addEventListener('keydown', async e => {
      if (e.key === 'Enter') {
        e.preventDefault();
        await applyStrainFilter();
      }
    });

    document.getElementById('toggle-strain-list').addEventListener('click', () => {
      setStrainListVisible(!strainListVisible);
    });

    document.getElementById('close-strain-list').addEventListener('click', () => {
      setStrainListVisible(false);
    });

    document.getElementById('strain-list-search').addEventListener('input', () => {
      renderStrainList();
    });

    document.getElementById('strain-list').addEventListener('click', async e => {
      const target = e.target.closest('.strain-item');
      if (!target) return;
      const strain = target.getAttribute('data-strain') || '';
      const input = document.getElementById('strain-filter');
      if (input) input.value = strain;
      await applyStrainFilter();
    });

    // =========================================================
    // Destination dropdown + markers
    // =========================================================

    /**
     * Rebuild the destination dropdown based on filters, sorting favourites first.
     */
    function updateDestinationDropdown() {
      const destSelect = document.getElementById('destination-select');
      const previousSelection = getSelectedDestinationIndex();
      destSelect.innerHTML = '';

      const items = locations
        .map((loc, i) => {
          // Filter by category selection
          if (!passesCategoryFilter(loc, i)) return null;

          const isFav = favorites.includes(i);
          const distText = lastPosition
            ? (haversineDistance(lastPosition, loc.coords) / 1000).toFixed(2) + ' km'
            : '';

          return { index: i, name: loc.name, distText, isFav };
        })
        .filter(x => x);

      // Sort favourites first, then alphabetically
      items.sort((a, b) => {
        if (a.isFav && !b.isFav) return -1;
        if (!a.isFav && b.isFav) return 1;
        return a.name.localeCompare(b.name);
      });

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.text = items.length ? 'Select a destination...' : 'No destinations for current filters';
      placeholder.disabled = true;
      placeholder.selected = true;
      destSelect.appendChild(placeholder);

      items.forEach(item => {
        const opt = document.createElement('option');
        opt.value = item.index;
        opt.text = item.name + (item.isFav ? ' ★' : '');
        destSelect.appendChild(opt);
      });

      const canRestoreSelection = previousSelection !== null &&
        items.some(item => item.index === previousSelection);
      if (canRestoreSelection) {
        destSelect.value = String(previousSelection);
      } else {
        destSelect.value = '';
        clearRouteUi();
      }

      updateDistanceInfo();
    }

    /**
     * Update distance label for currently selected destination.
     */
    function updateDistanceInfo() {
      const i = getSelectedDestinationIndex();
      const distanceDiv = document.getElementById('distance-info');

      if (lastPosition && i !== null) {
        const distText = (haversineDistance(lastPosition, locations[i].coords) / 1000).toFixed(2) + ' km';
        distanceDiv.textContent = 'Distance: ' + distText;
      } else if (distanceDiv) {
        distanceDiv.textContent = '';
      }
    }

    /**
     * Show or hide markers based on category filters.
     */
    function updateMarkers() {
      locations.forEach((loc, i) => {
        const visible = passesCategoryFilter(loc, i);
        if (visible) {
          if (!map.hasLayer(markers[i])) map.addLayer(markers[i]);
        } else {
          if (map.hasLayer(markers[i])) map.removeLayer(markers[i]);
        }
      });
    }

    // =========================================================
    // Favourites, visited, rating interactions
    // =========================================================

    // Handle favourite (Add / Remove) button clicks in popups
    document.body.addEventListener('click', e => {
      if (e.target.classList.contains('fav-btn')) {
        const i = parseInt(e.target.getAttribute('data-index'));
        const idx = favorites.indexOf(i);

        if (idx > -1) {
          favorites.splice(idx, 1);
        } else if (favorites.length < 10) {
          favorites.push(i);
        } else {
          return alert('Maximum of 10 favorites reached.');
        }

        localStorage.setItem('favorites', JSON.stringify(favorites));
        updateDestinationDropdown();

        e.target.textContent = favorites.includes(i)
          ? 'Remove from Favorites'
          : 'Add to Favorites';
      }
    });

    // Handle visited checkbox changes
    document.body.addEventListener('change', e => {
      if (e.target.classList.contains('visited-checkbox')) {
        const i = parseInt(e.target.getAttribute('data-index'));
        if (!isNaN(i) && locations[i]) {
          locations[i].visited = e.target.checked;
        }
      }
    });

    // Handle rating star clicks: cycle rating from 1–5
    document.body.addEventListener('click', e => {
      if (e.target.classList.contains('rating-stars')) {
        const i = parseInt(e.target.getAttribute('data-index'));
        if (isNaN(i) || !locations[i]) return;

        let current = locations[i].rating || 0;
        // Cycle 1 → 2 → 3 → 4 → 5 → 1 ...
        current = current >= 5 ? 1 : current + 1;

        locations[i].rating = current;
        e.target.setAttribute('data-rating', current);
        e.target.textContent = renderStars(current);
      }
    });

    // =========================================================
    // Nearest button
    // =========================================================

    document.getElementById('nearest-btn').addEventListener('click', () => {
      if (!lastPosition) {
        return alert('Current position not available yet.');
      }

      let nearestOutsideRadius = null;
      let minOutside = Infinity;
      let nearestAny = null;
      let minAny = Infinity;

      locations.forEach((loc, idx) => {
        if (!passesCategoryFilter(loc, idx)) return;

        const d = haversineDistance(lastPosition, loc.coords);

        // Track absolute nearest (for fallback)
        if (d < minAny) {
          minAny = d;
          nearestAny = idx;
        }

        // Track nearest that isn't effectively "where we already are"
        if (d > VISITED_RADIUS_METERS && d < minOutside) {
          minOutside = d;
          nearestOutsideRadius = idx;
        }
      });

      // Prefer a location not essentially on top of us
      const chosenIndex = (nearestOutsideRadius !== null) ? nearestOutsideRadius : nearestAny;
      if (chosenIndex === null) {
        return alert('No locations found for selected categories.');
      }

      const destSelect = document.getElementById('destination-select');
      destSelect.value = chosenIndex;
      destSelect.dispatchEvent(new Event('change'));
    });

    // =========================================================
    // UI toggles (controls + directions)
    // =========================================================

    document.getElementById('toggle-controls').addEventListener('click', () => {
      setControlsVisible(!controlsVisible);
    });

    document.getElementById('toggle-directions').addEventListener('click', () => {
      setDirectionsVisible(!directionsVisible);
    });

    bootstrapInitialCsvLoad();

    // Optional: probe DB routes early so status is visible before CSV upload.
    ensureDbIntegration();

    // =========================================================
    // Service worker (optional offline support)
    // =========================================================

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js');
    }
  </script>
</body>
</html>
